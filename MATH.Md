# Technical Documentation for the Quadratic Irrational PRNG

 **Attribution Note**: The mathematical foundation and core algorithm design presented in this document is based on amazing work of the illustruous Vincent Granville (2024), specifically his research on military-grade random number generators using quadratic irrationals that I ran into in the dead of night after having way too much coffee. While Granville provided the original Python implementation, this doc describes my R/C++ implementation developed primarily for educational purposes. Cool if you find it useful. Even better if you find a bug! 

 **Reference**: Granville, V. (2022). Synthetic Data and Generative AI 1st Edition. https://mltechniques.com/2022/12/13/military-grade-fast-random-number-generator-based-on-quadratic-irrationals/

## 1. Mathematical Foundation: The Quadratic Map

### 1.1 Basic Principle

The core algorithm, as described by Granville (2024), is based on a quadratic recurrence relation of the form:

```
x_{n+1} = (a*x_n^2 + b*x_n + c) mod 1
```

Where:
- `x_n` is the current state (a value in [0,1])
- `a`, `b`, and `c` are integer parameters
- `mod 1` means we take the fractional part of the result

This is a discrete dynamical system derived from the theory of quadratic irrationals. When properly configured, this map exhibits chaotic behavior, making it suitable for random number generation.

### 1.2 The Discriminant Requirement

The discriminant of the quadratic equation is defined as:

```
Δ = b² - 4ac
```

**Why the discriminant must be positive:**

1. **Mathematical reasons**: A positive discriminant ensures that the quadratic equation `ax² + bx + c = 0` has two distinct real roots. This is essential because:
   
   - When Δ > 0, the quadratic map has two fixed points in the real domain
   - These fixed points create a bounded region where chaotic behavior occurs
   - The sequence will "bounce" unpredictably between these boundaries

2. **Randomness quality**: When the discriminant is positive, the sequence exhibits sensitive dependence on initial conditions (the "butterfly effect"), a hallmark of chaotic systems that produces high-quality randomness.

3. **Sequence behavior**: 
   - Negative discriminant: The sequence would converge to a predictable pattern
   - Zero discriminant: The sequence would gravitate toward a single fixed point
   - Only a positive discriminant creates the necessary "stretching and folding" dynamic for chaos

### 1.3 Orbit Structure

The sequence generated by this recurrence relation creates what mathematicians call an "orbit" in dynamical systems theory. With proper parameters, this orbit:

- Densely fills the interval [0,1]
- Never repeats exactly (with sufficient precision)
- Has a uniform distribution of points
- Exhibits exponential divergence of nearby starting values

## 2. Parameter Constraints and Their Reasoning

### 2.1 Parameter `a`

**Constraint**: `a > 0` (must be positive)

**Reasoning**:
- Controls the "stretching" factor of the map
- If negative, would invert the parabola and destroy the chaotic properties
- If zero, would degenerate into a linear map with poor randomness

### 2.2 Parameter `c`

**Constraint**: `c < 0` (must be negative)

**Reasoning**:
- Together with `a > 0`, ensures the parabola crosses the x-axis in the right places
- Creates the correct topology for the chaotic attractor
- Ensures the mapping stays within [0,1] after taking the fractional part

### 2.3 Discriminant: `b² - 4ac > 0`

**Reasoning**:
- As explained above, ensures two real fixed points
- Creates the mathematical foundation for chaotic behavior
- Prevents the sequence from falling into simple patterns

### 2.4 Parameter Selection Guidelines

For optimal randomness properties:

1. **Coprime values**: Ideally, parameters `a`, `b`, and `c` should be coprime (no common divisors)
2. **Moderate values**: While any valid values will work mathematically, moderate values (e.g., 1-10) are more numerically stable
3. **High precision**: Higher MPFR precision increases the period length and quality of randomness

## 3. MultiQI Implementation

### 3.1 Round-Robin Approach

The package implements a "round-robin" approach using multiple Quadratic Irrational (QI) sequences:

1. **Multiple QI sequences**: 
   - Creates several independent QI sequences, each with its own (a,b,c) parameters
   - Maintains separate state for each sequence

2. **Round-robin generation**:
   - Cycles through the sequences in order
   - Each call to `next()` advances to the next sequence
   - This creates additional randomness by mixing outputs from different chaotic systems

3. **Mathematical benefits**:
   - Increases the effective period length
   - Reduces potential patterns within a single QI sequence
   - Creates a multi-dimensional chaotic system

### 3.2 Parameter Diversification

The implementation uses a carefully selected set of (a,b,c) parameters:

1. **Parameter selection**:
   - Parameters are chosen to have positive discriminants
   - Different parameters create sequences with different orbital characteristics
   - Parameter selection affects the "mixing speed" of the sequence

2. **Random skipping**:
   - Each QI sequence is initialized and then skipped a random number of steps
   - This ensures different starting points even with the same parameters
   - Prevents potential synchronization of sequences

## 4. Cryptographic Mixing

### 4.1 Purpose and Motivation

While the quadratic irrational generator produces sequences with good statistical properties, adding cryptographic mixing provides:

1. **Enhanced statistical quality**: Eliminates subtle patterns that might exist in the raw sequence
2. **Cryptographic security**: Makes the output suitable for cryptographic applications
3. **Defense against analysis**: Prevents potential mathematical analysis of the underlying sequence

### 4.2 Mixing Approaches

The package implements two different approaches for cryptographic mixing:

#### 4.2.1 Partial Modular Addition (Default)

```
x_mixed = (x_original + crypto_uniform) mod 1
```

Where:
- `x_original` is the raw value from the quadratic irrational generator
- `crypto_uniform` is a cryptographically secure random value in [0,1)
- The result is taken modulo 1 to keep it in [0,1)

**Benefits**:
- Preserves the uniform distribution
- Cryptographically strong
- Efficiently eliminates patterns in the original sequence

#### 4.2.2 Partial Averaging (Alternative)

An alternative approach that uses weighted averaging instead of modular addition, activated with the `adhoc_corrections` flag:

```
x_mixed = (x_original + crypto_uniform) / 2
```

**Differences**:
- May provide slight differences in statistical behavior
- Included as an alternative mixing strategy for testing

### 4.3 Integration with Core Generator

The cryptographic mixing integrates with the core generator in several ways:

1. **Buffer-based processing**: 
   - Values are generated in buffers for efficiency
   - Entire buffers are cryptographically processed at once

2. **Reseeding mechanism**:
   - Both the quadratic parameters and the encryption key are replaced during reseeding
   - Reseeding can occur automatically after a specified number of generated values

3. **Careful handling of sensitive data**:
   - Encryption keys are stored in secure memory
   - Keys are properly zeroed when no longer needed using sodium_memzero
   - Side-channel mitigation techniques are employed

### 4.4 Tie-Breaking Mechanism

The implementation includes a tie-breaking mechanism to handle the rare case of duplicate consecutive values:

1. **Detection**:
   - Checks if the current output exactly equals the previous output
   - Such exact duplications are extremely rare but possible

2. **Resolution**:
   - Adds a tiny random epsilon value to break the tie
   - The epsilon is small enough not to affect the distribution
   - Ensures consecutive identical values never occur

3. **Benefits**:
   - Prevents potential issues in applications that expect unique values
   - Provides additional entropy in edge cases
   - Maintains the overall statistical properties

## 5. Distribution Transformations

The raw uniform [0,1] values can be transformed into various probability distributions:

### 5.1 Uniform Range

Transforms uniform [0,1] to uniform [min, max]:
```
y = min + x*(max - min)
```

### 5.2 Normal Distribution

Uses the Box-Muller transform to generate normally distributed values:
```
r = sqrt(-2*ln(u1))
θ = 2π*u2
x = mean + sd * r*cos(θ)
y = mean + sd * r*sin(θ)
```

Where u1 and u2 are independent uniform [0,1] values. The implementation optimizes this by storing the second value (y) for the next call, effectively using both random numbers generated from each pair of uniform draws.

### 5.3 Exponential Distribution

Uses the inverse transform method:
```
x = -ln(1-u)/λ
```

Where u is a uniform [0,1] value and λ is the rate parameter.

## 6. Precision and Numerical Considerations

### 6.1 MPFR Precision

The package uses the GNU MPFR library for arbitrary-precision arithmetic:

- **Default**: 53 bits (equivalent to double precision)
- **Range**: 24 to 10,000 bits (package limit)
- **Impact**: Higher precision increases cycle length and improves statistical properties

### 6.2 Numerical Stability

Considerations for numerical stability:

- **Overflow protection**: All calculations use arbitrary precision to prevent overflow
- **Underflow handling**: Special handling for values close to zero
- **Modular reduction**: Exact fractional part calculation ensures values stay in [0,1)

### 6.3 Period Length

With sufficient precision, the period length of the generator is extremely long:

- At 53-bit precision: effectively non-repeating for practical applications
- At higher precisions: period grows exponentially
- With cryptographic mixing: period becomes cryptographically large

### 6.4 Fixed Point Avoidance

A critical consideration in the implementation is avoiding fixed points. A fixed point is a value x where f(x) = x, meaning the sequence would get stuck at this value.

**Issues with Fixed Points:**
- Early implementations using the fractional part of 1/(ax + b) could converge to fixed points (e.g., 0.1861407...)
- Once convergence occurs, random numbers are no longer generated, as all subsequent values are identical
- This severely impacts the statistical properties and utility of the PRNG

**Solution:**
1. The current implementation uses the full quadratic map (ax² + bx + c mod 1)
2. The choice of parameters (a>0, c<0) ensures no fixed points in [0,1]
3. Even if a fixed point were approached, cryptographic mixing would move the state away
4. Random initial values and seeding further prevent fixed point convergence

## 7. Thread Safety and Parallelism

### 7.1 Thread Safety Mechanisms

The package provides two approaches to thread safety:

1. **Global Mutex Protection**:
   - When `use_threading = FALSE` (default)
   - A global mutex protects access to the PRNG state
   - Ensures only one thread can access the PRNG at a time
   - Guarantees sequence reproducibility but may limit parallelism

2. **Thread-Local Instances**:
   - When `use_threading = TRUE`
   - Each thread gets its own independent PRNG instance
   - No mutex contention, allowing full parallelism
   - Different random sequences in each thread

### 7.2 Mathematical Implications of Threading

Using thread-local PRNG instances has important mathematical implications:

1. **Independence**:
   - Sequences generated in different threads are statistically independent
   - No correlation between sequences across threads
   - Reduces potential for pattern emergence in parallel applications

2. **Reproducibility**:
   - With global mutex: sequence is reproducible regardless of threading
   - With thread-local instances: each thread's sequence is reproducible but different
   - Important consideration for scientific computing and simulation

3. **Performance vs. Determinism**:
   - Thread-local instances offer better performance but less predictability
   - Global mutex offers deterministic results but may be slower in highly threaded applications
   - Choice depends on application requirements

## 8. Secure Memory Management

### 8.1 SecureBuffer Implementation

The package uses a template class called `SecureBuffer` for secure memory management:

1. **RAII Design**:
   - Resource Acquisition Is Initialization pattern
   - Automatically handles proper cleanup of sensitive data
   - Prevents memory leaks and security vulnerabilities

2. **Secure Memory Clearing**:
   - Overwrites memory with zeros before deallocation
   - Uses volatile pointers to prevent compiler optimization
   - Ensures sensitive data (like encryption keys) is securely erased

3. **Memory Safety**:
   - Type-safe wrapper around std::vector
   - Prevents buffer overflows and memory corruption
   - Simplifies memory management throughout the codebase

### 8.2 Side-Channel Mitigation

The implementation includes several measures to reduce side-channel attack vectors:

1. **Constant-time operations** where possible
2. **Avoidance of secret-dependent control flow**
3. **Protection against timing attacks**
4. **Use of libsodium's secure memory functions**

### 8.3 Application to Sensitive Data

SecureBuffer is applied to:
- Cryptographic keys
- Nonces
- Temporary buffers containing sensitive data
- Any other security-critical components

## 9. Statistical Properties

### 9.1 Uniformity

The raw output of the generator has been analyzed for uniformity:

1. **Kolmogorov-Smirnov tests**: Testing goodness-of-fit to the uniform distribution
2. **Frequency tests**: Counting the occurrence of each digit/bit
3. **Chi-square tests**: Testing if the distribution matches the expected uniform distribution

The sequence shows excellent uniformity, especially when:
- Using higher precision values
- Enabling cryptographic mixing
- Using multiple QI sequences (MultiQI approach)

### 9.2 Independence

Sequential values in the output should be independent. Tests include:

1. **Autocorrelation analysis**: Measuring correlation between values at different lags
2. **Runs tests**: Testing the distribution of runs of consecutive values above/below the median
3. **2D visualization**: Plotting pairs of consecutive values to detect patterns

Results show high independence, especially with:
- Cryptographic mixing enabled
- Proper parameter selection
- Sufficient precision

### 9.3 Long-Range Behavior

The PRNG has been tested for long-range behavior:

1. **Spectral analysis**: Examining the Fourier transform for periodic components
2. **Entropy estimation**: Measuring the effective entropy of long sequences
3. **Compression tests**: Testing if the sequence can be compressed (indicating patterns)

Even over billions of values, no significant long-range patterns have been detected.

## 10. Implementation Note on Use of SecureBuffer

The qiprng implementation uses the SecureBuffer template class for secure memory management of sensitive data. This class:

1. Provides RAII-style memory management, automatically clearing sensitive data when it goes out of scope
2. Implements a secure clearing procedure that overwrites memory with zeros before deallocation
3. Ensures that cryptographic keys and other sensitive values are properly handled

When implementing or modifying code, it's important to:
- Always use SecureBuffer for any security-sensitive data
- Avoid creating unnecessary copies of sensitive data
- Allow the SecureBuffer destructor to handle clearing instead of manual clearing
- Remember that SecureBuffer constructor takes only a size parameter, not an initializer value
