# Technical Documentation for the Quadratic Irrational PRNG

> **Attribution Note**: The mathematical foundation and core algorithm design presented in this document is based on amazing work of Vincent Granville (2024), specifically his research on military-grade random number generators using quadratic irrationals. While Granville provided the original Python implementation, this document describes our independent R/C++ implementation developed for educational purposes.
>
> **Reference**: Granville, V. (2024). Synthetic Data and Generative AI 1st Edition. https://mltechniques.com/2022/12/13/military-grade-fast-random-number-generator-based-on-quadratic-irrationals/

## 1. Mathematical Foundation: The Quadratic Map

### 1.1 Basic Principle

The core algorithm, as described by Granville (2024), is based on a quadratic recurrence relation of the form:

```
x_{n+1} = (a*x_n^2 + b*x_n + c) mod 1
```

Where:
- `x_n` is the current state (a value in [0,1])
- `a`, `b`, and `c` are integer parameters
- `mod 1` means we take the fractional part of the result

This is a discrete dynamical system derived from the theory of quadratic irrationals. When properly configured, this map exhibits chaotic behavior, making it suitable for random number generation.

### 1.2 The Discriminant Requirement

The discriminant of the quadratic equation is defined as:

```
Δ = b² - 4ac
```

**Why the discriminant must be positive:**

1. **Mathematical reasons**: A positive discriminant ensures that the quadratic equation `ax² + bx + c = 0` has two distinct real roots. This is essential because:
   
   - When Δ > 0, the quadratic map has two fixed points in the real domain
   - These fixed points create a bounded region where chaotic behavior occurs
   - The sequence will "bounce" unpredictably between these boundaries

2. **Randomness quality**: When the discriminant is positive, the sequence exhibits sensitive dependence on initial conditions (the "butterfly effect"), a hallmark of chaotic systems that produces high-quality randomness.

3. **Sequence behavior**: 
   - Negative discriminant: The sequence would converge to a predictable pattern
   - Zero discriminant: The sequence would gravitate toward a single fixed point
   - Only a positive discriminant creates the necessary "stretching and folding" dynamic for chaos

### 1.3 Orbit Structure

The sequence generated by this recurrence relation creates what mathematicians call an "orbit" in dynamical systems theory. With proper parameters, this orbit:

- Densely fills the interval [0,1]
- Never repeats exactly (with sufficient precision)
- Has a uniform distribution of points
- Exhibits exponential divergence of nearby starting values

## 2. Parameter Constraints and Their Reasoning

### 2.1 Parameter `a`

**Constraint**: `a > 0` (must be positive)

**Reasoning**:
- Controls the "stretching" factor of the map
- If negative, would invert the parabola and destroy the chaotic properties
- If zero, would degenerate into a linear map with poor randomness

### 2.2 Parameter `c`

**Constraint**: `c < 0` (must be negative)

**Reasoning**:
- Together with `a > 0`, ensures the parabola crosses the x-axis in the right places
- Creates the correct topology for the chaotic attractor
- Ensures the mapping stays within [0,1] after taking the fractional part

### 2.3 Discriminant: `b² - 4ac > 0`

**Reasoning**:
- As explained above, ensures two real fixed points
- Creates the mathematical foundation for chaotic behavior
- Prevents the sequence from falling into simple patterns

### 2.4 Parameter Selection Guidelines

For optimal randomness properties:

1. **Coprime values**: Ideally, parameters `a`, `b`, and `c` should be coprime (no common divisors)
2. **Moderate values**: While any valid values will work mathematically, moderate values (e.g., 1-10) are more numerically stable
3. **High precision**: Higher MPFR precision increases the period length and quality of randomness

## 3. Cryptographic Mixing

### 3.1 Purpose and Motivation

While the quadratic irrational generator produces sequences with good statistical properties, adding cryptographic mixing provides:

1. **Enhanced statistical quality**: Eliminates subtle patterns that might exist in the raw sequence
2. **Cryptographic security**: Makes the output suitable for cryptographic applications
3. **Defense against analysis**: Prevents potential mathematical analysis of the underlying sequence

### 3.2 AES-256-CTR Implementation

The package uses AES-256 in Counter Mode (CTR) for cryptographic mixing:

1. **Process**:
   - Generate raw values using the quadratic map
   - Convert to binary representation
   - Apply AES-256-CTR encryption
   - Convert back to uniform values in [0,1]

2. **Security features**:
   - 256-bit key generated from a hardware RNG or secure source
   - Automatic key rotation during reseeding
   - Counter mode ensures no patterns are introduced during encryption

### 3.3 Integration with Core Generator

The cryptographic mixing integrates with the core generator in several ways:

1. **Buffer-based processing**: 
   - Values are generated in buffers for efficiency
   - Entire buffers are cryptographically processed at once

2. **Reseeding mechanism**:
   - Both the quadratic parameters and the encryption key are replaced during reseeding
   - Reseeding can occur automatically after a specified number of generated values
   - Hardware RNG can be used for reseeding when available

3. **Careful handling of sensitive data**:
   - Encryption keys are stored in secure memory
   - Keys are properly zeroed when no longer needed
   - Side-channel mitigation techniques are employed

## 4. Distribution Transformations

The raw uniform [0,1] values can be transformed into various probability distributions:

### 4.1 Uniform Range

Transforms uniform [0,1] to uniform [min, max]:
```
y = min + x*(max - min)
```

### 4.2 Normal Distribution

Uses the Box-Muller transform to generate normally distributed values:
```
r = sqrt(-2*ln(u1))
θ = 2π*u2
x = mean + sd * r*cos(θ)
y = mean + sd * r*sin(θ)
```

Where u1 and u2 are independent uniform [0,1] values.

### 4.3 Exponential Distribution

Uses the inverse transform method:
```
x = -ln(1-u)/λ
```

Where u is a uniform [0,1] value and λ is the rate parameter.

## 5. Precision and Numerical Considerations

### 5.1 MPFR Precision

The package uses the GNU MPFR library for arbitrary-precision arithmetic:

- **Default**: 53 bits (equivalent to double precision)
- **Range**: 2 to 10,000 bits (package limit)
- **Impact**: Higher precision increases cycle length and improves statistical properties

### 5.2 Numerical Stability

Considerations for numerical stability:

- **Overflow protection**: All calculations use arbitrary precision to prevent overflow
- **Underflow handling**: Special handling for values close to zero
- **Modular reduction**: Exact fractional part calculation ensures values stay in [0,1]

### 5.3 Period Length

With sufficient precision, the period length of the generator is extremely long:

- At 53-bit precision: effectively non-repeating for practical applications
- At higher precisions: period grows exponentially
- With cryptographic mixing: period becomes cryptographically large

## 6. Implementation Details

### 6.1 Thread Safety

- Uses mutex locking for thread-safe operation
- Separate buffers prevent race conditions
- In multi-threaded environments, each thread gets independent random sequences

### 6.2 Hardware RNG Integration

- Attempts to use hardware RNG (RDRAND/RDSEED) when available
- Falls back to high-quality software RNG (libsodium)
- User can configure whether to prioritize hardware RNG

### 6.3 Automatic Reseeding

- Configurable reseeding interval
- Resets quadratic parameters using secure entropy
- Regenerates cryptographic keys
- Mitigates theoretical concerns about cycle finding

## 7. Statistical Testing and Quality Assurance

The QIPRNG implementation has been validated using various statistical tests:

- Kolmogorov-Smirnov test for uniformity
- Runs test for independence
- FFT test for periodic patterns
- Distribution-specific tests for transformed outputs

For all supported distributions, the package ensures that outputs pass rigorous statistical tests to confirm their adherence to the expected probability distributions.

## 8. Mathematical Foundations of Quadratic Irrational PRNG

### 8.1 Core Algorithm

The PRNG is based on the iteration of a quadratic map in the interval [0,1):

x_{n+1} = ax_n² + bx_n + c (mod 1)

where:
- a, b, c are integer parameters
- x_n is the nth iterate in [0,1)
- The operation (mod 1) takes the fractional part

### 8.2 Requirements for Chaotic Behavior

1. **Discriminant Condition**:
   The quadratic equation must have irrational roots to ensure non-periodic behavior.
   - Discriminant D = b² - 4ac must be positive
   - √D must be irrational

2. **Parameter Constraints**:
   - a > 0: Ensures quadratic behavior
   - c < 0: Required for proper mapping to [0,1)
   - |b| chosen to satisfy discriminant condition

### 8.3 Mathematical Properties

1. **Ergodicity**:
   The map is ergodic on [0,1) when parameters satisfy above conditions.
   This ensures:
   - Uniform distribution of iterates
   - No periodic orbits
   - Sensitive dependence on initial conditions

2. **Mixing Property**:
   The quadratic nature provides strong mixing:
   - Adjacent points diverge exponentially
   - Correlation between successive iterates decays exponentially

3. **Period Length**:
   - Theoretically infinite due to irrational roots
   - Practical period limited by floating-point precision
   - MPFR implementation allows arbitrary precision

## 9. Distribution Transformations

### 9.1 Uniform [0,1)
Direct output of quadratic map, no transformation needed.

### 9.2 Normal Distribution (Box-Muller)
For u₁, u₂ ~ Uniform[0,1):
```
r = √(-2 ln u₁)
θ = 2π u₂
x = r cos θ
y = r sin θ
```
Then x, y ~ N(0,1)

Numerical Considerations:
- u₁ > ε where ε = std::numeric_limits<double>::epsilon()
- Handle edge cases near 0 to avoid log(0)

### 9.3 Exponential Distribution
For u ~ Uniform[0,1):
```
x = -ln(1-u)/λ
```
where λ is the rate parameter.

### 9.4 Uniform Range [a,b]
Linear transformation:
```
x = a + u(b-a)
```
where u ~ Uniform[0,1)

## 10. Cryptographic Enhancement

The raw output of the quadratic map is enhanced using:

1. **AES-256-CTR Mode**:
   - Applies cryptographic mixing to blocks of generated numbers
   - Preserves uniform distribution
   - Adds cryptographic strength to statistical randomness

2. **Key Management**:
   - 256-bit keys generated using system CSPRNG
   - Regular reseeding based on sample count
   - Secure key and IV storage using sodium_memzero

## 11. Statistical Properties

1. **Uniformity**:
   - Theoretically perfect due to ergodicity
   - Practically verified using:
     * Kolmogorov-Smirnov test
     * Chi-square test
     * Spectral test

2. **Independence**:
   - Successive values show no correlation
   - Verified using:
     * Serial correlation test
     * Runs test
     * Lag-k autocorrelation

3. **Period Length**:
   - Depends on MPFR precision setting
   - Default 53-bit precision gives ~2⁵³ unique values
   - Can be increased for longer periods

## 12. Implementation Notes

1. **Precision Management**:
   - MPFR used for arbitrary-precision arithmetic
   - Default precision matches IEEE double (53 bits)
   - Higher precision available but impacts performance

2. **Buffer Management**:
   - Numbers generated in blocks for efficiency
   - Crypto mixing applied to entire blocks
   - Thread-safe access via mutex

3. **Performance Considerations**:
   - MPFR operations are the main performance bottleneck
   - Crypto mixing has minimal impact due to block processing
   - Buffer size tunable for performance vs. memory trade-off

## 13. References

1. Knuth, D. E. "The Art of Computer Programming, Volume 2: Seminumerical Algorithms"
2. L'Ecuyer, P. "Random Number Generation"
3. NIST Special Publication 800-90A: "Recommendation for Random Number Generation"