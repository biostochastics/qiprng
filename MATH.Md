# Technical Documentation for the Quadratic Irrational PRNG

 **Attribution Note**: The mathematical foundation and core algorithm design presented in this document is based on amazing work of the illustruous Vincent Granville (2024), specifically his research on military-grade random number generators using quadratic irrationals that I ran into in the dead of night after having way too much coffee. While Granville provided the original Python implementation, this doc describes my R/C++ implementation developed primarily for educational purposes. Cool if you find it useful. Even better if you find a bug! 

 **Reference**: Granville, V. (2022). Synthetic Data and Generative AI 1st Edition. https://mltechniques.com/2022/12/13/military-grade-fast-random-number-generator-based-on-quadratic-irrationals/

## 1. Mathematical Foundation: The Quadratic Map

### 1.1 Basic Principle

The core algorithm, as described by Granville (2024), is based on a quadratic recurrence relation of the form:

```
x_{n+1} = (a*x_n^2 + b*x_n + c) mod 1
```

Where:
- `x_n` is the current state (a value in [0,1])
- `a`, `b`, and `c` are integer parameters
- `mod 1` means we take the fractional part of the result

This is a discrete dynamical system derived from the theory of quadratic irrationals. When properly configured, this map exhibits chaotic behavior, making it suitable for random number generation.

### 1.2 The Discriminant Requirement

The discriminant of the quadratic equation is defined as:

```
Δ = b² - 4ac
```

**Why the discriminant must be positive:**

1. **Mathematical reasons**: A positive discriminant ensures that the quadratic equation `ax² + bx + c = 0` has two distinct real roots. This is essential because:
   
   - When Δ > 0, the quadratic map has two fixed points in the real domain
   - These fixed points create a bounded region where chaotic behavior occurs
   - The sequence will "bounce" unpredictably between these boundaries

2. **Randomness quality**: When the discriminant is positive, the sequence exhibits sensitive dependence on initial conditions (the "butterfly effect"), a hallmark of chaotic systems that produces high-quality randomness.

3. **Sequence behavior**: 
   - Negative discriminant: The sequence would converge to a predictable pattern
   - Zero discriminant: The sequence would gravitate toward a single fixed point
   - Only a positive discriminant creates the necessary "stretching and folding" dynamic for chaos

### 1.3 Orbit Structure

The sequence generated by this recurrence relation creates what mathematicians call an "orbit" in dynamical systems theory. With proper parameters, this orbit:

- Densely fills the interval [0,1]
- Never repeats exactly (with sufficient precision)
- Has a uniform distribution of points
- Exhibits exponential divergence of nearby starting values

## 2. Parameter Constraints and Their Reasoning

### 2.1 Parameter `a`

**Constraint**: `a > 0` (must be positive)

**Reasoning**:
- Controls the "stretching" factor of the map
- If negative, would invert the parabola and destroy the chaotic properties
- If zero, would degenerate into a linear map with poor randomness

### 2.2 Parameter `c`

**Constraint**: `c < 0` (must be negative)

**Reasoning**:
- Together with `a > 0`, ensures the parabola crosses the x-axis in the right places
- Creates the correct topology for the chaotic attractor
- Ensures the mapping stays within [0,1] after taking the fractional part

### 2.3 Discriminant: `b² - 4ac > 0`

**Reasoning**:
- As explained above, ensures two real fixed points
- Creates the mathematical foundation for chaotic behavior
- Prevents the sequence from falling into simple patterns

### 2.4 Parameter Selection Guidelines

For optimal randomness properties:

1. **Coprime values**: Ideally, parameters `a`, `b`, and `c` should be coprime (no common divisors)
2. **Moderate values**: While any valid values will work mathematically, moderate values (e.g., 1-10) are more numerically stable
3. **High precision**: Higher MPFR precision increases the period length and quality of randomness

## 3. Cryptographic Mixing

### 3.1 Purpose and Motivation

While the quadratic irrational generator produces sequences with good statistical properties, adding cryptographic mixing provides:

1. **Enhanced statistical quality**: Eliminates subtle patterns that might exist in the raw sequence
2. **Cryptographic security**: Makes the output suitable for cryptographic applications
3. **Defense against analysis**: Prevents potential mathematical analysis of the underlying sequence

### 3.2 ChaCha20 Implementation

The package uses ChaCha20 for cryptographic mixing:

1. **Process**:
   - Generate raw values using the quadratic map
   - Convert to binary representation
   - Apply ChaCha20 stream cipher
   - Convert back to uniform values in [0,1]

2. **Security features**:
   - Generated key and nonce from secure cryptographic random source
   - Automatic key rotation during reseeding
   - Stream cipher ensures no patterns are introduced during encryption

### 3.3 Integration with Core Generator

The cryptographic mixing integrates with the core generator in several ways:

1. **Buffer-based processing**: 
   - Values are generated in buffers for efficiency
   - Entire buffers are cryptographically processed at once

2. **Reseeding mechanism**:
   - Both the quadratic parameters and the encryption key are replaced during reseeding
   - Reseeding can occur automatically after a specified number of generated values

3. **Careful handling of sensitive data**:
   - Encryption keys are stored in secure memory
   - Keys are properly zeroed when no longer needed using sodium_memzero
   - Side-channel mitigation techniques are employed

## 4. Distribution Transformations

The raw uniform [0,1] values can be transformed into various probability distributions:

### 4.1 Uniform Range

Transforms uniform [0,1] to uniform [min, max]:
```
y = min + x*(max - min)
```

### 4.2 Normal Distribution

Uses the Box-Muller transform to generate normally distributed values:
```
r = sqrt(-2*ln(u1))
θ = 2π*u2
x = mean + sd * r*cos(θ)
y = mean + sd * r*sin(θ)
```

Where u1 and u2 are independent uniform [0,1] values. The implementation optimizes this by storing the second value (y) for the next call, effectively using both random numbers generated from each pair of uniform draws.

### 4.3 Exponential Distribution

Uses the inverse transform method:
```
x = -ln(1-u)/λ
```

Where u is a uniform [0,1] value and λ is the rate parameter.

## 5. Precision and Numerical Considerations

### 5.1 MPFR Precision

The package uses the GNU MPFR library for arbitrary-precision arithmetic:

- **Default**: 53 bits (equivalent to double precision)
- **Range**: 2 to 10,000 bits (package limit)
- **Impact**: Higher precision increases cycle length and improves statistical properties

### 5.2 Numerical Stability

Considerations for numerical stability:

- **Overflow protection**: All calculations use arbitrary precision to prevent overflow
- **Underflow handling**: Special handling for values close to zero
- **Modular reduction**: Exact fractional part calculation ensures values stay in [0,1]

### 5.3 Period Length

With sufficient precision, the period length of the generator is extremely long:

- At 53-bit precision: effectively non-repeating for practical applications
- At higher precisions: period grows exponentially
- With cryptographic mixing: period becomes cryptographically large

### 5.4 Fixed Point Avoidance

A critical consideration in the implementation is avoiding fixed points. A fixed point is a value x where f(x) = x, meaning the sequence would get stuck at this value.

**Issues with Fixed Points:**
- Early implementations using the fractional part of 1/(ax + b) could converge to fixed points (e.g., 0.1861407...)
- Once convergence occurs, random numbers are no longer generated, as all subsequent values are identical
- This severely impacts the statistical properties and utility of the PRNG

**Solution:**
1. The current implementation uses the full quadratic map (ax² + bx + c mod 1)
2. Proper handling of the fractional part calculation:
   - Using floor subtraction instead of direct modular arithmetic
   - Special handling for negative values by adding 1 to ensure results stay in [0,1)
3. These changes ensure the sequence:
   - Has more chaotic behavior
   - Avoids convergence to fixed points
   - Maintains uniform distribution

Mathematically, the quadratic map has more complex dynamics than simpler maps like 1/(ax + b), making it less likely to settle into periodic orbits with small periods, especially when properly implemented with high-precision arithmetic.

## 6. Implementation Details

### 6.1 Thread Safety

- Uses mutex locking for thread-safe operation
- Separate buffers prevent race conditions
- In multi-threaded environments, each thread gets independent random sequences

### 6.2 Error Handling

The implementation includes comprehensive error handling:

1. **Parameter validation**: 
   - All parameters are validated before use
   - Invalid parameters throw clear exception messages
   - No silent fallbacks to default values

2. **Numerical checks**:
   - Edge cases like values ≤ 0 or ≥ 1 are detected and corrected
   - Special handling for potential floating-point anomalies

3. **Error reporting**:
   - In R mode: Errors are properly reported via R's error mechanisms
   - Debug mode provides additional diagnostics when enabled

## 7. Statistical Properties

### 7.1 Uniformity

The raw sequence from the quadratic map has excellent uniformity properties:

1. **Empirical distribution**: 
   - Closely approximates a uniform distribution in [0,1]
   - Passes standard statistical tests for uniformity

2. **Independence**:
   - Low serial correlation between consecutive values
   - No detectable patterns in the sequence

### 7.2 Long-Range Behavior

The long-range behavior of the sequence is also favorable:

1. **Cycle length**:
   - Theoretically infinite due to irrational roots
   - Practical period limited by floating-point precision
   - MPFR implementation allows arbitrary precision

2. **Ergodicity**:
   - The sequence effectively "explores" the entire [0,1] interval
   - Long-term frequency distribution matches theoretical uniform distribution

### 7.3 With Cryptographic Mixing

When cryptographic mixing is enabled:

1. **Enhanced randomness**:
   - Any subtle patterns in the raw sequence are eliminated
   - Statistical quality increases to cryptographic levels

2. **Non-predictability**:
   - Forward and backward prediction become computationally infeasible
   - Side-channel protection through secure memory handling

## 8. Performance Considerations

### 8.1 Computational Efficiency

The implementation balances statistical quality with performance:

1. **Buffer-based generation**:
   - Values are generated in chunks to amortize overhead
   - User-configurable buffer size allows tuning based on memory/speed tradeoffs

2. **Predictable memory usage**:
   - Memory requirements scale linearly with buffer size and precision
   - No unbounded growth or leaks during long-running simulations

### 8.2 Optimizations

Several optimizations are included:

1. **Box-Muller efficiency**:
   - Normal distribution generation uses both values from the Box-Muller transform
   - Reduces computational cost by using the "spare" normal variate

2. **Configuration parsing**:
   - Direct parsing of configuration lists avoids redundant object creation
   - Streamlined parameter validation

### 8.3 Memory Safety

The implementation prioritizes memory safety:

1. **Secure buffers**:
   - Sensitive data is zeroed before deallocation
   - Uses libsodium's secure memory wiping functions

2. **Resource management**:
   - RAII pattern ensures proper cleanup of resources
   - No memory leaks in error cases

## 9. Practical Usage Guidelines

### 9.1 Selecting Parameters

Guidelines for selecting optimal parameters:

1. **Quadratic coefficients**:
   - Use moderate values (e.g., 1-10) for a, b, and c
   - Ensure the discriminant b² - 4ac is positive
   - Prefer values that are coprime to each other

2. **Precision settings**:
   - Default (53 bits) is sufficient for most applications
   - Increase for extremely long sequences or specialized applications
   - Higher precision increases memory usage and reduces performance

### 9.2 Distribution Settings

Tips for working with different distributions:

1. **Normal distribution**:
   - Set appropriate mean and standard deviation
   - Be aware that extreme values are possible (though rare)

2. **Exponential distribution**:
   - Lambda parameter controls the rate of decay
   - Higher lambda values concentrate more probability mass near zero

### 9.3 Cryptographic Usage

For cryptographic applications:

1. **Always enable cryptographic mixing**:
   - Set `use_crypto_mixing = TRUE`
   - Consider periodic reseeding for long-running applications

2. **Conservative usage**:
   - While the implementation follows best practices, it has not undergone formal cryptographic review which duh
   - Please, please, please use established cryptographic libraries for critical security applications. I ain't your momma, no.
