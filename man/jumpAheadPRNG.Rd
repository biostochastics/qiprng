% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prng_interface.R
\name{jumpAheadPRNG}
\alias{jumpAheadPRNG}
\title{Jump ahead in the PRNG sequence}
\usage{
jumpAheadPRNG(n)
}
\arguments{
\item{n}{Number of steps to jump ahead (positive integer or numeric value).
Can be astronomically large (e.g., 1e18) as the implementation uses
O(log n) matrix exponentiation for optimal performance.}
}
\value{
Invisibly returns NULL
}
\description{
Advances the PRNG state by skipping ahead n numbers using O(log n) matrix
exponentiation with MPFR precision arithmetic. This is exponentially more
efficient than generating and discarding n numbers, enabling astronomical
jumps (e.g., 10^18 steps) in microseconds.
}
\details{
The jump-ahead functionality is particularly useful for:
\itemize{
\item Parallel simulations where different workers need non-overlapping sequences
\item Subsampling from specific points in the random sequence
\item Skipping large segments without the computational cost of generation
\item Creating independent streams separated by astronomical distances
}

Version 0.5.0 introduces revolutionary O(log n) complexity using:
\itemize{
\item Matrix exponentiation with binary powering algorithm
\item Continued Fraction Expansion (CFE) period detection using Gauss-Legendre
\item MPFR arbitrary precision arithmetic for numerical stability
\item Automatic optimization selection based on jump size and CFE period
}

Performance characteristics:
\itemize{
\item Small jumps (< 1000): Direct iteration
\item Medium jumps (1000-1M): Block processing with cache optimization
\item Large jumps (> 1M): O(log n) matrix exponentiation
\item Astronomical jumps (> 10^9): Pure logarithmic scaling
}

Note: Due to the security-focused design with random initialization, two PRNGs
created with identical parameters may start at different positions in the
sequence. The jump-ahead function advances from the current position, not from
a fixed origin.

Thread safety: This function is fully thread-safe and will block until mutex
is acquired. The implementation ensures proper synchronization of all thread-local
storage during jump-ahead operations.
}
\examples{
# Create default PRNG
createPRNG()

# Generate some initial values
initial_values <- generatePRNG(5)

# Jump ahead 1000 values
jumpAheadPRNG(1000)

# Generate values after the jump
after_jump_values <- generatePRNG(5)

# Large jumps are handled efficiently
jumpAheadPRNG(1e6) # Jump ahead 1 million steps

# Use for parallel simulations
\dontrun{
# Worker 1: uses steps 0-999999
createPRNG()
worker1_values <- generatePRNG(1000000)

# Worker 2: uses steps 1000000-1999999
createPRNG()
jumpAheadPRNG(1000000)
worker2_values <- generatePRNG(1000000)
}
}
