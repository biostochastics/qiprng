---
title: 'C++ Architecture'
description: 'Design patterns and architecture of the qiprng C++ implementation'
sidebarTitle: 'Architecture Overview'
---

# C++ Architecture Overview

The qiprng C++ implementation follows a modular, high-performance architecture designed for thread safety, numerical precision, and computational efficiency.

## Design Principles

<CardGroup cols={2}>
  <Card title="Thread Safety" icon="shield">
    All components use mutex protection and thread-local storage for safe concurrent access
  </Card>
  <Card title="Zero-Copy Operations" icon="zap">
    Buffers and state management minimize memory allocations during generation
  </Card>
  <Card title="SIMD Optimization" icon="microchip">
    Vectorized operations using AVX2/NEON for maximum throughput
  </Card>
  <Card title="Precision Control" icon="calculator">
    MPFR integration for arbitrary precision arithmetic when needed
  </Card>
</CardGroup>

## Core Components

### 1. QuadraticIrrational Class

The foundation class that implements continued fraction expansion:

```cpp
class QuadraticIrrational {
    mpfr_t a, d, c;           // High-precision state
    std::vector<long> cfe;    // CFE coefficients
    size_t period;            // Period length

    void computeCFE();        // O(period) initialization
    double getNext();         // O(1) amortized generation
};
```

**Key Features:**
- Automatic period detection
- Overflow-safe arithmetic
- Multiple jump-ahead algorithms
- Cache-friendly coefficient storage

### 2. EnhancedPRNG Class

High-level generator managing multiple quadratic irrationals:

```cpp
class EnhancedPRNG {
    std::vector<QuadraticIrrational*> qis;  // Ensemble
    BufferManager buffer;                   // Pre-generated values
    CryptoMixer* mixer;                     // Optional mixing
    std::mutex gen_mutex;                   // Thread safety

    void fillBuffer();                      // Parallel generation
    double generate();                      // Thread-safe API
};
```

**Architecture Decisions:**
- **Ensemble approach**: Multiple QIs for increased period and quality
- **Buffer strategy**: Pre-generation for consistent performance
- **Mixing options**: Pluggable entropy sources

### 3. CryptoMixer Component

Provides cryptographic hardening:

```cpp
class CryptoMixer {
    ChaCha20 cipher;
    uint8_t key[32], nonce[12];
    uint64_t counter;

    void mix(double* values, size_t count);
};
```

**Security Features:**
- Forward and backward secrecy
- Uniform distribution preservation
- Minimal performance overhead (~15%)

## Memory Layout

<Note>
**Optimization**: All critical data structures are aligned to cache lines (64 bytes) to prevent false sharing in multi-threaded scenarios.
</Note>

```cpp
struct alignas(64) ThreadState {
    size_t thread_id;
    QuadraticIrrational* qi;
    double* buffer;
    size_t buffer_pos;
    // Padding to cache line
};
```

## SIMD Vectorization

The implementation leverages platform-specific SIMD instructions:

### AVX2 (x86_64)

```cpp
__m256d generate_avx2() {
    __m256d state = _mm256_load_pd(state_ptr);
    __m256d a = _mm256_set1_pd(coeff_a);
    __m256d b = _mm256_set1_pd(coeff_b);
    __m256d c = _mm256_set1_pd(coeff_c);

    // x² term
    __m256d x2 = _mm256_mul_pd(state, state);
    __m256d ax2 = _mm256_mul_pd(a, x2);

    // bx term
    __m256d bx = _mm256_mul_pd(b, state);

    // Complete quadratic
    __m256d result = _mm256_add_pd(ax2, bx);
    result = _mm256_add_pd(result, c);

    // Modulo 1.0
    result = _mm256_sub_pd(result, _mm256_floor_pd(result));

    return result;
}
```

### NEON (ARM64)

```cpp
float64x2_t generate_neon() {
    float64x2_t state = vld1q_f64(state_ptr);
    float64x2_t a = vdupq_n_f64(coeff_a);

    // Quadratic computation
    float64x2_t x2 = vmulq_f64(state, state);
    float64x2_t result = vfmaq_f64(c, b, state);
    result = vfmaq_f64(result, a, x2);

    // Modulo operation
    return vsubq_f64(result, vrndmq_f64(result));
}
```

## Parallelization Strategy

### OpenMP Thread Pool

```cpp
void fillBufferParallel() {
    #pragma omp parallel for schedule(dynamic, 16)
    for (size_t i = 0; i < buffer_size; i += chunk_size) {
        size_t tid = omp_get_thread_num();
        ThreadState& ts = thread_states[tid];

        for (size_t j = 0; j < chunk_size; ++j) {
            buffer[i + j] = ts.qi->getNext();
        }
    }
}
```

### Work Distribution

<Warning>
**Critical**: Dynamic scheduling with chunk size 16 provides optimal load balancing across cores while minimizing synchronization overhead.
</Warning>

## Error Handling

The architecture employs a multi-level error handling strategy:

1. **Compile-time checks**: Static assertions for configuration validity
2. **Runtime validation**: Parameter bounds checking
3. **Graceful degradation**: Fallback to scalar operations if SIMD fails
4. **Exception safety**: Strong exception guarantee for all public APIs

```cpp
template<typename T>
T safe_generate() {
    std::lock_guard<std::mutex> lock(gen_mutex);

    try {
        if (buffer_empty()) {
            fillBuffer();  // May throw
        }
        return static_cast<T>(buffer[pos++]);
    } catch (const std::exception& e) {
        // Log error and use fallback
        return fallback_generate<T>();
    }
}
```

## Performance Characteristics

### Memory Usage

| Component | Size | Notes |
|-----------|------|-------|
| Per QI state | ~8 KB | CFE coefficients + MPFR state |
| Buffer | 8 KB default | Configurable (1024 doubles) |
| Thread state | 256 bytes/thread | Cache-aligned |
| Total overhead | ~100 KB | For typical 8-thread configuration |

### Computational Complexity

| Operation | Complexity | Typical Time |
|-----------|------------|--------------|
| Initialization | O(period) | 50 ms |
| Single value | O(1) amortized | 122 ns |
| Buffer refill | O(buffer_size) | 125 μs |
| Jump-ahead | O(log n) | 15 μs |

## Build Configuration

### Preprocessor Flags

```cpp
#ifdef USE_AVX2
    // AVX2 optimizations enabled
#elif defined(USE_NEON)
    // ARM NEON optimizations
#else
    // Scalar fallback
#endif

#ifdef QIPRNG_DEBUG
    // Additional validation and logging
#endif

#ifdef USE_OPENMP
    // Parallel buffer filling
#endif
```

### Compiler Optimizations

Recommended flags for maximum performance:

```makefile
CXXFLAGS = -O3 -march=native -mtune=native \
           -funroll-loops -fprefetch-loop-arrays \
           -ffast-math -fopenmp
```

## Future Enhancements

<Info>
**Roadmap**: Planned architectural improvements for future versions
</Info>

1. **GPU Acceleration**: CUDA/OpenCL kernels for massive parallel generation
2. **SIMD-512**: AVX-512 support for next-gen Intel processors
3. **Lock-free buffers**: Wait-free circular buffer implementation
4. **JIT Compilation**: Runtime code generation for optimal parameters
5. **Quantum Integration**: Post-quantum cryptographic mixing options

## Design Patterns Used

### Factory Pattern
```cpp
std::unique_ptr<PRNG> PRNGFactory::create(const Config& cfg) {
    switch (cfg.type) {
        case PRNGType::ENHANCED:
            return std::make_unique<EnhancedPRNG>(cfg);
        case PRNGType::MULTI_QI:
            return std::make_unique<MultiQI>(cfg);
    }
}
```

### Strategy Pattern
```cpp
class MixingStrategy {
    virtual void mix(double* data, size_t n) = 0;
};

class XORMixing : public MixingStrategy { /* ... */ };
class ChaCha20Mixing : public MixingStrategy { /* ... */ };
```

### RAII for Resource Management
```cpp
class MPFRGuard {
    mpfr_t value;
public:
    MPFRGuard(unsigned prec) { mpfr_init2(value, prec); }
    ~MPFRGuard() { mpfr_clear(value); }
    // Deleted copy, move semantics only
};
```

## Thread Safety Guarantees

The architecture provides different levels of thread safety:

1. **Global instance**: Mutex-protected, safe but contended
2. **Thread-local**: No synchronization needed, maximum performance
3. **Pool-based**: Pre-allocated instances with work stealing

```cpp
// Thread-local storage for zero-contention access
thread_local EnhancedPRNG* tls_prng = nullptr;

double generate_threadsafe() {
    if (!tls_prng) {
        tls_prng = new EnhancedPRNG(global_config);
    }
    return tls_prng->generate();
}
```

## Benchmarking Architecture

The system includes built-in benchmarking capabilities:

```cpp
class Benchmark {
    std::chrono::high_resolution_clock clock;
    std::vector<double> timings;

    void run(size_t iterations) {
        for (size_t i = 0; i < iterations; ++i) {
            auto start = clock.now();
            // Operation to benchmark
            auto end = clock.now();
            timings.push_back(duration(end - start));
        }
    }

    BenchmarkResults analyze() {
        // Statistical analysis of timings
    }
};
```

This architecture achieves the optimal balance between performance, security, and maintainability while providing flexibility for future enhancements.
