---
title: 'Quadratic Irrational'
description: 'C++ implementation details for quadratic_irrational.hpp'
---

## Overview

File: quadratic_irrational.hpp

## Classes

### QuadraticIrrational

Jump-ahead algorithm selection for efficient sequence advancement Different algorithms offer various trade-offs between speed and overflow safety: - ORIGINAL_128BIT: Fastest but may overflow for very large jumps - MPFR_MATRIX: Safest, handles arbitrary precision but slower - MODULAR_MERSENNE: Good balance using 2^61-1 prime modulus - DIRECT_CFE: Avoids matrix operations entirely / enum class JumpAheadAlgorithm { ORIGINAL_128BIT = 0,   // Original implementation with 128-bit arithmetic (may overflow) MPFR_MATRIX = 1,       // Use MPFR for matrix operations (no overflow, slower) MODULAR_MERSENNE = 2,  // Use modular arithmetic with Mersenne prime (fast, no overflow) DIRECT_CFE = 3         // Direct CFE manipulation without matrices }; / 2x2 Matrix for efficient CFE jump-ahead operations Represents transformation matrices used in the jump-ahead algorithm. Matrix multiplication is used to compute large jumps in O(log n) time via binary exponentiation. The matrix represents: [p q] [r s] / struct Matrix2x2 { long p, q, r, s; Matrix2x2(long p_ = 1, long q_ = 0, long r_ = 0, long s_ = 1) : p(p_), q(q_), r(r_), s(s_) {} / Matrix multiplication with overflow protection Uses 128-bit arithmetic when available, otherwise uses builtin overflow checks / Matrix2x2 operator*(const Matrix2x2& other) const { #ifdef __SIZEOF_INT128__ // Use 128-bit arithmetic for overflow protection using int128_t = __int128; int128_t pp = static_cast<int128_t>(p) * other.p + static_cast<int128_t>(q) * other.r; int128_t pq = static_cast<int128_t>(p) * other.q + static_cast<int128_t>(q) * other.s; int128_t rp = static_cast<int128_t>(r) * other.p + static_cast<int128_t>(s) * other.r; int128_t rs = static_cast<int128_t>(r) * other.q + static_cast<int128_t>(s) * other.s; // Check if results fit in long constexpr int128_t LONG_MAX_128 = static_cast<int128_t>(LONG_MAX); constexpr int128_t LONG_MIN_128 = static_cast<int128_t>(LONG_MIN); if (pp > LONG_MAX_128 || pp < LONG_MIN_128 || pq > LONG_MAX_128 || pq < LONG_MIN_128 || rp > LONG_MAX_128 || rp < LONG_MIN_128 || rs > LONG_MAX_128 || rs < LONG_MIN_128) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } return Matrix2x2(static_cast<long>(pp), static_cast<long>(pq), static_cast<long>(rp), static_cast<long>(rs)); #else // Fallback: Check for overflow using builtin functions (GCC/Clang) long new_p, new_q, new_r, new_s; long temp1, temp2; // Calculate p * other.p + q * other.r if (__builtin_smull_overflow(p, other.p, &temp1) || __builtin_smull_overflow(q, other.r, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_p)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate p * other.q + q * other.s if (__builtin_smull_overflow(p, other.q, &temp1) || __builtin_smull_overflow(q, other.s, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_q)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate r * other.p + s * other.r if (__builtin_smull_overflow(r, other.p, &temp1) || __builtin_smull_overflow(s, other.r, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_r)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate r * other.q + s * other.s if (__builtin_smull_overflow(r, other.q, &temp1) || __builtin_smull_overflow(s, other.s, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_s)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } return Matrix2x2(new_p, new_q, new_r, new_s); #endif } / Binary exponentiation for O(log n) jump-ahead / Matrix2x2 power(uint64_t n) const; }; / Quadratic Irrational Number Generator This class represents a quadratic irrational number of the form (a + √d)/c and provides methods for continued fraction expansion and random number generation. The CFE produces a sequence of coefficients that, when properly normalized, yield uniformly distributed random numbers. Mathematical Properties: - The discriminant b²-4ac must be positive and not a perfect square - The continued fraction expansion is eventually periodic - The period length affects the quality of randomness - NOT thread-safe; each thread should have its own instance - Or use external synchronization when sharing instances - Next value generation: O(1) amortized - Jump-ahead by n: O(log n) - Initialization: O(period_length)

## Methods

### `power()`

```cpp
Matrix2x2 power(...)
```

Jump-ahead algorithm selection for efficient sequence advancement Different algorithms offer various trade-offs between speed and overflow safety: - ORIGINAL_128BIT: Fastest but may overflow for very large jumps - MPFR_MATRIX: Safest, handles arbitrary precision but slower - MODULAR_MERSENNE: Good balance using 2^61-1 prime modulus - DIRECT_CFE: Avoids matrix operations entirely / enum class JumpAheadAlgorithm { ORIGINAL_128BIT = 0,   // Original implementation with 128-bit arithmetic (may overflow) MPFR_MATRIX = 1,       // Use MPFR for matrix operations (no overflow, slower) MODULAR_MERSENNE = 2,  // Use modular arithmetic with Mersenne prime (fast, no overflow) DIRECT_CFE = 3         // Direct CFE manipulation without matrices }; / 2x2 Matrix for efficient CFE jump-ahead operations Represents transformation matrices used in the jump-ahead algorithm. Matrix multiplication is used to compute large jumps in O(log n) time via binary exponentiation. The matrix represents: [p q] [r s] / struct Matrix2x2 { long p, q, r, s; Matrix2x2(long p_ = 1, long q_ = 0, long r_ = 0, long s_ = 1) : p(p_), q(q_), r(r_), s(s_) {} / Matrix multiplication with overflow protection Uses 128-bit arithmetic when available, otherwise uses builtin overflow checks / Matrix2x2 operator*(const Matrix2x2& other) const { #ifdef __SIZEOF_INT128__ // Use 128-bit arithmetic for overflow protection using int128_t = __int128; int128_t pp = static_cast<int128_t>(p) * other.p + static_cast<int128_t>(q) * other.r; int128_t pq = static_cast<int128_t>(p) * other.q + static_cast<int128_t>(q) * other.s; int128_t rp = static_cast<int128_t>(r) * other.p + static_cast<int128_t>(s) * other.r; int128_t rs = static_cast<int128_t>(r) * other.q + static_cast<int128_t>(s) * other.s; // Check if results fit in long constexpr int128_t LONG_MAX_128 = static_cast<int128_t>(LONG_MAX); constexpr int128_t LONG_MIN_128 = static_cast<int128_t>(LONG_MIN); if (pp > LONG_MAX_128 || pp < LONG_MIN_128 || pq > LONG_MAX_128 || pq < LONG_MIN_128 || rp > LONG_MAX_128 || rp < LONG_MIN_128 || rs > LONG_MAX_128 || rs < LONG_MIN_128) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } return Matrix2x2(static_cast<long>(pp), static_cast<long>(pq), static_cast<long>(rp), static_cast<long>(rs)); #else // Fallback: Check for overflow using builtin functions (GCC/Clang) long new_p, new_q, new_r, new_s; long temp1, temp2; // Calculate p * other.p + q * other.r if (__builtin_smull_overflow(p, other.p, &temp1) || __builtin_smull_overflow(q, other.r, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_p)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate p * other.q + q * other.s if (__builtin_smull_overflow(p, other.q, &temp1) || __builtin_smull_overflow(q, other.s, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_q)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate r * other.p + s * other.r if (__builtin_smull_overflow(r, other.p, &temp1) || __builtin_smull_overflow(s, other.r, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_r)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } // Calculate r * other.q + s * other.s if (__builtin_smull_overflow(r, other.q, &temp1) || __builtin_smull_overflow(s, other.s, &temp2) || __builtin_saddl_overflow(temp1, temp2, &new_s)) { throw std::overflow_error("Matrix multiplication overflow in jump-ahead operation"); } return Matrix2x2(new_p, new_q, new_r, new_s); #endif } / Binary exponentiation for O(log n) jump-ahead

#### Parameters

- **other**: The matrix to multiply with
- **n**: The exponent

#### Returns

This matrix raised to the nth power

**Complexity:** O(log n) matrix multiplications

<Warning>
**Throws:** std::overflow_error if result doesn't fit in long
</Warning>

### `compute_cfe_period()`

```cpp
void compute_cfe_period(...)
```

Computes the continued fraction expansion (CFE) period of the quadratic irrational number.
